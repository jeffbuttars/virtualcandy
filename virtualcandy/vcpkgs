#!/usr/bin/env python
# encoding: utf-8

import os
import sys
import json
import argparse
import crayons
from pprint import pformat
from pipenv.project import Project
from pipenv.utils import convert_deps_from_pip


PROFILE_D_SCRIPT = '/etc/profile.d/virtualcandy.sh'
PROFILE_TMPL = """
# Generated file, do not edit or risk being over written or deleted.
if [[ -n $ZSH_NAME ]]; then
    if [[ -f "{incl}.zsh" ]]; then
        . "{incl}.zsh"
    fi
elif [[ -f "{incl}.sh" ]]; then
    . "{incl}.sh"
fi
"""


class PipLock(object):
    def __init__(self, fd=None):
        self._fd = fd or open(os.path.join(os.getcwd(), 'Pipfile.lock'), 'r')
        self._pf = json.load(self._fd)
        self._def_key = 'default'
        self._dev_key = 'develop'

    def _to_freeeze_list(self, pkgs):
        res = []
        for k, v in pkgs.items():
            if isinstance(v, dict) and v.get('version'):
                res.append("%s%s" % (k, v.get('version')))

        return res

    def has(self, pkg_name):
        return self.has_def(pkg_name) or self.has_dev(pkg_name)

    def has_dev(self, pkg_name):
        return pkg_name in self.develop

    def has_def(self, pkg_name):
        return pkg_name in self.default

    @property
    def default(self):
        return self._pf.get(self._def_key, {})

    @property
    def default_freeze(self):
        return self._to_freeeze_list(self.default)

    @property
    def develop(self):
        return self._pf.get(self._dev_key, {})

    @property
    def develop_freeze(self):
        return self._to_freeeze_list(self.develop)

    def __str__(self):
        return pformat(self._pf)

    def __repr__(self):
        return pformat(self._pf)


def freeze(args, pl):
    if args.dev:
        print('\n'.join(pl.develop_freeze))
    else:
        print('\n'.join(pl.default_freeze))


def pkgs(args, pl):
    pkg = args.pkg[0]
    res = ''

    if pl.has_def(pkg):
        res = 'default'
    elif pl.has_dev(pkg):
        res = 'develop'

    print(res)


def install(args, pl):
    from distutils.sysconfig import get_python_lib
    plibs = os.path.join(get_python_lib(), 'virtualcandy', 'lib')

    #  if args.system:
    #      # System wide install, way to commit!
    #      try:
    #          with open(PROFILE_D_SCRIPT, 'w') as fd:
    #              fd.write(PROFILE_TMPL.format(incl=os.path.join(plibs, 'virtualcandy')))

    #          os.chmod(PROFILE_D_SCRIPT, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH | stat.S_IWUSR)
    #          print("The system wide Virtualcandy start up file has been installed!")
    #          print("You may need to now logout and log in again, or even restart, for")
    #          print("your shell to start using Virtualcandy. Thank your for installing!")
    #          return
    #      except PermissionError as e:
    #          print("You don't have permission to perform a system install.")
    #          print("Retry the installation as root, or re-run the command with `sudo`:")
    #          print('\tsudo ' + ' '.join(sys.argv))
    #          sys.exit(1)

    # Kind of stupid and only supports zsh or bash
    shell = os.path.basename(os.environ.get('SHELL'))
    if os.environ.get('ZSH_NAME'):
        shell = 'zsh'

    ext = 'sh'
    if args.zsh:
        ext = 'zsh'
    elif not args.sh:
        shell = os.path.basename(os.environ.get('SHELL'))
        if shell == 'zsh':
            ext = shell

    incl = os.path.join(plibs, f'virtualcandy.{ext}')

    home = os.path.expanduser('~')
    src = os.path.join(home, '.bashrc')
    if ext == 'zsh':
        src = os.path.join(home, '.zshrc')

    shell_snip = (
        f'\n# To activate Virtualcandy for your shell'
        f'\n# add the following 3 lines into your {src} file\n'
        f'if [[ -f "{incl}" ]]; then\n'
        f'    . "{incl}"\n'
        'fi\n'
    )

    print(shell_snip)


def convert(args, pl):
    project = Project()

    # If a Pipfile exists, do nothing
    if not args.force and project.pipfile_exists:
        print(crayons.red(f'Pipfile {project.pipfile_location} already exists, not converting.'))
        return

    if not project.requirements_exists:
        print(crayons.red("Can't find requirements file for project, not converting."))
        return

    if not project.pipfile_exists:
        print(crayons.yellow(('Creating Pipfile from existing requirements at '
                              f'{project.requirements_location} ...')))
        project.create_pipfile()

    pipfile = project.parsed_pipfile
    pipfile['packages'] = pipfile['packages'] if 'packages' in pipfile else {}
    pipfile['dev-packages'] = pipfile['dev-packages'] if 'dev-packages' in pipfile else {}

    req_file = project.requirements_location
    # Name/prefix of dev reqs file should be configurable
    dev_req_file = os.path.join(os.path.dirname(req_file), 'dev-requirements.txt')

    packages = []
    dev_packages = []
    with open(req_file, 'r') as f:
        packages = [p for p in f.read().split('\n') if p != '']

    if os.path.exists(dev_req_file):
        print(crayons.yellow(f'Adding development requirements from {dev_req_file}'))
        with open(dev_req_file, 'r') as f:
            dev_packages = [p for p in f.read().split('\n') if p != '']

    for package in packages:
        dep = convert_deps_from_pip(package)
        pipfile['packages'].update(dep)

    for package in dev_packages:
        dep = convert_deps_from_pip(package)
        pipfile['dev-packages'].update(dep)

    project.write_toml(pipfile)
    print(crayons.yellow('Updated pipfile with packages from existing requirements files'))


def main(parser):
    args = parser.parse_args()

    try:
        pl = PipLock(fd=args.lock_file)
    except Exception:
        pl = None

    if hasattr(args, 'func'):
        args.func(args, pl)
        sys.exit(0)

    parser.print_help()
    sys.exit(1)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Virtual Candy packaging helper')
    parser.add_argument('--dev', action='store_true',
                        help='Apply operation as development packaging'
                        )
    parser.add_argument('--lock-file', type=argparse.FileType('r'),
                        help='Specify the path to the lock file'
                        )

    subparsers = parser.add_subparsers()

    parser_freeze = subparsers.add_parser(
        'freeze',
        aliases=['f', 'fr'],
        help="Create 'pip freeze' output from locked packages."
    )
    parser_freeze.add_argument('--freeze', default=True)
    parser_freeze.set_defaults(func=freeze)

    parser_info = subparsers.add_parser(
        'info',
        aliases=['i'],
        help="Get info about a pkg. Currently just reports if a package is default or dev"
    )
    parser_info.add_argument(
        'pkg',
        nargs=argparse.ONE_OR_MORE,
        help="The name of the package to look for info on."
    )
    parser_info.set_defaults(func=pkgs)

    parser_install = subparsers.add_parser(
        'install',
        help="Install the shell code needed for a per user install."
    )
    parser_install.add_argument(
        '--sh', action='store_true',
        help="Install for bash shell"
    )
    parser_install.add_argument(
        '--zsh', action='store_true',
        help="Install for zsh shell"
    )

    parser_convert = subparsers.add_parser(
        'convert',
        help=("Convert a purelyl pip based project that,"
              " uses requirements.txt files, to a Pipenv based project.")
    )
    parser_convert.set_defaults(func=convert)
    parser_convert.add_argument(
        '--force', action='store_true',
        help='Force the adding requirements entries into the Pipfile even if it exists'
    )

    #  parser_install.add_argument(
    #      '--system', action='store_true',
    #      help=(
    #          "Install globaly by creating /etc/profile.d/virtualcandy.sh, "
    #          "must by done with proper permsissions, \n"
    #          "\tex: `sudo dpkgs install --system`"
    #      )
    #  )
    parser_install.set_defaults(func=install)

    main(parser)
